(load "~/quicklisp/setup.lisp")
(ql:quickload "cl-ppcre")

(defun accumulate-scores (scores)
  (let* ((length (length scores))
         (out (make-array length :element-type 'double-float))
         (accumulator 0.0d0))
    (do ((i 0 (1+ i)))
        ((>= i length) out)
      (incf accumulator (1+ (aref scores i)))
      (setf (aref out i) accumulator))))

(defun pick-with-accumulated-scores (accumulated-scores)
  (let* ((length (length accumulated-scores))
         (top (aref accumulated-scores (1- length))))
    (if (> top 0)
        (let* ((r (random top))
               (a 0)
               (b length))
          (do ()
              ((>= a b) (values a r top))
            (let* ((pivot (floor (/ (+ a b) 2)))
                   (pivot-accumulated-score (aref accumulated-scores pivot)))
              (if (< pivot-accumulated-score r)
                  (setf a (1+ pivot))
                  (setf b pivot)))))
        (random length))))
        
(defun pick-with-scores (scores)
  (let ((accumulated-scores (accumulate-scores scores)))
    (pick-with-accumulated-scores accumulated-scores)))

(defun cross (a b)
  (let* ((length-a (length a))
         (length-b (length b))
         (cut-a (1+ (random length-a)))
         (cut-b (random length-b))
         (start-a (subseq a 0 cut-a))
         (end-b (subseq b cut-b length-b)))
    (concatenate 'string start-a end-b)))

(defun mutate-delete-char (a)
  (let* ((length-a (length a))
         (ix (random length-a))
         (start-a (subseq a 0 ix))
         (end-a (subseq a (1+ ix) length-a)))
    (concatenate 'string start-a end-a)))

(defparameter *alphabet* "abcdefghijklmnopqrstuvwxyz0123456789 !\"#$%&'()*+'-./:;<=>?@[\\]^_`")

(defun pick-from-alphabet ()
  (let* ((alphabet-length (length *alphabet*))
         (ix (random alphabet-length)))
    (values (aref *alphabet* ix) ix)))

(defun mutate-add-char (a)
  (let* ((length-a (length a))
         (ix (random length-a))
         (start-a (subseq a 0 ix))
         (middle (vector (pick-from-alphabet)))
         (end-a (subseq a ix length-a)))
    (concatenate 'string start-a middle end-a)))

(defun  mutate-overwrite-char (a)
  (let* ((length-a (length a))
         (ix (random length-a))
         (start-a (subseq a 0 ix))
         (middle (vector (pick-from-alphabet)))
         (end-a (subseq a (1+ ix) length-a)))
    (concatenate 'string start-a middle end-a)))

(defun mutate (a)
  (ecase (random 3)
    (0 (mutate-add-char a))
    (1 (mutate-delete-char a))
    (2 (mutate-overwrite-char a))))

(defun square (a) (* a a))

(defun scan-for-subseq-length (scanner good)
  (let ((good-length (length good)))
    (do ((subseq-length good-length (1- subseq-length)))
        ((= 0 subseq-length) 0)
      (do ((i 0 (1+ i)))
          ((> i (- good-length subseq-length)))
        (when (cl-ppcre:scan scanner (subseq good i (+ i subseq-length)))
          (return-from scan-for-subseq-length (/ subseq-length good-length)))))))
        
(defun score (regex goods bads)
  (let ((scanner (ignore-errors (cl-ppcre:create-scanner regex))))
    (if scanner
        (progn
          (dolist (bad bads)
            (when (cl-ppcre:scan scanner bad)
              (return-from score 1)))
          (let ((score 1))
            (dolist (good goods (/ score (1+ (length regex))))
              (incf score (* 10 (scan-for-subseq-length scanner good))))))
        (progn
          ;;(format t "compilation of >~A< failed~%" regex)
          1))))

(defun generate-n (population scores n)
  (let ((out (make-array n :fill-pointer 0))
        (accumulated-scores (accumulate-scores scores)))
    (dotimes (i n out)
      (let* ((a (aref population (pick-with-accumulated-scores accumulated-scores)))
             (element
              (if (= 0 (random 2))
                  (cross a (aref population
                                 (pick-with-accumulated-scores accumulated-scores)))
                  (mutate a))))
        ;;(format t "pushing >~A<, length ~A~%" element (length element))
        (when (> (length element) 0)
          (vector-push element out))))))


(defun scores (population goods bads)
  (let* ((length (length population))
         (out (make-array length)))
    (dotimes (i length out)
      (setf (aref out i) (score (aref population i) goods bads)))))

(defun sum-vector (scores)
  (let ((length (length scores))
        (acu 0))
    (dotimes (i length acu)
      (incf acu (aref scores i)))))

(defun pick-n-with-scores (population scores n)
  (let ((length (length scores))
        (total (sum-vector scores))
        (remaining n)
        (out (make-array n :fill-pointer 0)))
    ;;(format t "scores: ~A, total: ~A~%" scores total)
    (dotimes (i length out)
      (let ((score (aref scores i)))
        ;;(format t "total: ~A~%" total)
        (when (< (random (coerce total 'double-float)) (* score remaining))
          (decf remaining)
          (vector-push (aref population i) out))
        (decf total score)))))

(defun grow-population (population goods bads m n max)
  (let* ((scores (scores population goods bads))
         (accumulated (accumulate-scores scores)))
    ;;(format t "~A~%~A~%~A~%~%" population scores accumulated))
    )
  (if (> m 0)
      (let* ((scores (scores population goods bads))
             (population-2 (concatenate  'simple-vector population
                                        (generate-n population scores n)))
             (scores-2 (scores population-2 goods bads))
             (population-3 (pick-n-with-scores population-2 scores-2 max)))
        (grow-population population-3 goods bads (1- m) n max))
      population))

